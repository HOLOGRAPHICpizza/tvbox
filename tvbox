#!/usr/bin/env python

import asyncio
import vlc
import time
import signal
import threading
import sys

# do not create directly, use Channel.addEpisode
class Episode(object):
    filename: str
    start_time: int
    length: int

    def __init__(self, filename: str, start_time: int, length: int):
        self.filename = filename
        self.start_time = start_time
        self.length = length

class Channel(object):
    length: int
    episodes: list[Episode]
    current_episode_num: int

    def add_episode(self, filename: str, length: int):
        if len(self.episodes) == 0:
            start_time = 0
        else:
            start_time = self.episodes[-1].start_time + self.episodes[-1].length
        self.episodes.append(Episode(filename, start_time, length))
        self.length += length

    def __init__(self, channel_file: str):
        self.length = 0
        self.episodes = []
        self.current_episode_num = 0

        try:
            with open(channel_file, 'r') as file:
                    for line in file:
                        fields = line.split('|')
                        self.add_episode(fields[0], int(fields[1]))
        finally:
            file.close()

class TV(object):
    event_loop: asyncio.AbstractEventLoop
    channels: list[Channel]
    current_channel_num: int
    vlc_instance: vlc.Instance
    vlc_player: vlc.MediaPlayer

    def current_channel(self):
        return self.channels[self.current_channel_num]

    def add_channel(self, channel: Channel):
        self.channels.append(channel)

    def play_file(self, filename: str):
        assert threading.current_thread() == threading.main_thread()

        print('playing channel ' + str(self.current_channel_num)
              + ' episode ' + str(self.current_channel().current_episode_num)
              + ' filename ' + filename)

        self.vlc_player.stop()
        if self.vlc_media_instance is not None:
            self.vlc_media_instance.release()
        self.vlc_media_instance = self.vlc_instance.media_new(filename)
        self.vlc_player.set_media(self.vlc_media_instance)
        self.vlc_player.play()

    def play_channel(self, channel_num: int):
        assert threading.current_thread() == threading.main_thread()

        self.current_channel_num = channel_num
        #print('play channel ' + str(channel_num))

        # find time in playlist as a whole
        time_in_playlist = int(time.time()) % self.current_channel().length
        #print('playlist length ' + str(self.current_channel().length))
        #print('time in playlist ' + str(time_in_playlist))

        # determine episode
        episode_num = 0
        for i in range(len(self.current_channel().episodes)):
            e = self.current_channel().episodes[i]
            if e.start_time <= time_in_playlist < (e.start_time + e.length):
                episode_num = i
                break
        self.current_channel().current_episode_num = episode_num
        #print('episode num ' + str(episode_num))
        #print('filename ' + self.current_channel().episodes[episode_num].filename)

        self.play_file(self.current_channel().episodes[episode_num].filename)

        # player.set_fullscreen(True)

        # find time in episode
        time_in_episode = time_in_playlist - self.current_channel().episodes[episode_num].start_time
        print('seeking to ' + str(time_in_episode))
        self.vlc_player.set_time(time_in_episode * 1000)
        #print('episode length ' + str(self.current_channel().episodes[episode_num].length))
        #print('time in episode ' + str(time_in_episode))

    def next_episode(self):
        assert threading.current_thread() == threading.main_thread()

        next_episode_num = self.current_channel().current_episode_num + 1
        if next_episode_num == len(self.current_channel().episodes):
            next_episode_num = 0
        self.current_channel().current_episode_num = next_episode_num

        self.play_file(self.current_channel().episodes[next_episode_num].filename)

    def __init__(self, event_loop: asyncio.AbstractEventLoop):
        self.event_loop = event_loop
        self.channels = []
        self.current_channel_num = 0

        self.vlc_instance = vlc.Instance()
        self.vlc_player = self.vlc_instance.media_player_new()
        self.vlc_media_instance = None

def custom_exception_handler(loop, context):
    # first, handle with default handler
    loop.default_exception_handler(context)

    #exception = context.get('exception')
    print(context, flush=True)
    loop.stop()
    sys.exit(1)

class TermException(Exception):
    pass

def sigterm_handler(_signo, _stack_frame):
    raise TermException

if __name__ == '__main__':
    #print('Main thread: ' + str(threading.get_ident()))
    print('tvbox started')

    signal.signal(signal.SIGTERM, sigterm_handler)

    _event_loop = asyncio.get_event_loop()
    _event_loop.set_debug(False)
    _event_loop.set_exception_handler(custom_exception_handler)

    tv = TV(_event_loop)

    # next channel
    def sigusr1_handler(_signo, _stack_frame):
        print('sigusr1_handler thread: ' + str(threading.get_ident()))

    # next episode
    def media_end_handler(event: vlc.Event):
        #print('media_end_handler thread: ' + str(threading.get_ident()))

        # python-vlc is not reentrant, we must control vlc from the main thread
        tv.event_loop.call_soon_threadsafe(tv.next_episode)

    signal.signal(signal.SIGUSR1, sigusr1_handler)

    try:
        tv.add_channel(Channel('testvids.channel'))

        tv.play_channel(0)

        event_manager = tv.vlc_player.event_manager()
        event_manager.event_attach(vlc.EventType.MediaPlayerEndReached, media_end_handler)

        tv.event_loop.run_forever()

    except KeyboardInterrupt:
        print('Caught SIGINT, tvbox exiting.', flush=True)

    except TermException:
        print('Caught SIGTERM, tvbox exiting.', flush=True)

    finally:
        # Stop playback and release resources
        tv.vlc_player.stop()
        tv.vlc_media_instance.release()
        tv.vlc_player.release()
        tv.event_loop.close()